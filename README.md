
## Numble 뱅킹 서버 챌린지


```kotlin

     +-------------+          +---------------+
     |   Member    |          |    Account    |
     +-------------+          +---------------+
     | id          | 1     *  | id            |
     | username    |          | name          |
     | password    |          | balance       |
     +-------------+          | owner_id (FK) |
            |                 +---------------+
            |                          |
           *  *                        |
    +-----------------+                *
    |    Friendship   |       +-----------------+
    +-----------------+       |    Transaction  |
    | id              |       +-----------------+
    | user_id (FK)    |       | id              |
    | friend_id (FK)  |       | from_account_id |
    +-----------------+       | to_account_id   |
                              | amount          |
                              +-----------------+
```

*Member* 엔티티는 `username`과 `password` 필드를 갖습니다. `password` 필드는 인코딩된 비밀번호를 담습니다.

*Friendship* 엔티티는 `Member` 엔티티의 다대다 자기참조 관계를 표현하기 위한 엔티티입니다.  2개의 외래키인 `user_id`, `friend_id`를 가지며, 각각 `Member` 엔티티의 `id`를 나타냅니다. Friendship 엔티티를 만들 때 가장 고민한 점은, 친구관계가 양방향 관계라는 점이었습니다. 즉 내가 어떤 친구를 친구로 추가했다면, 그 친구의 친구목록에도 내가 들어가야 하는데,  이는 마치 무방향 그래프와도 같아서 하나의 친구관계가 양쪽에서 모두 공유됩니다. 여러 사이트를 검색해보았을 때, 뚜렷한 해답은 없었지만 이 경우 마치 그래프의 양방향 간선을 양쪽 노드의 인접리스트에 둘 다 삽입하듯이,  관계를 나타나는 엔티티를 양쪽 엔티티에 전부 생성하는 방안이 있다는 것을 찾아냈고 이를 사용하였습니다. 즉, 한 유저가 다른 유저를 친구로 추가하면, 그 유저를 `user_id` 로 갖고 추가한 친구를 `friend_id` 로 갖는 `Friendship` 엔티티가 1개, 추가된 친구를 `user_id`  로 갖고 추가한 친구를 `friend_id` 로 갖는 `Friendship` 엔티티가 1개 더 저장됩니다.

*Account* 엔티티는 `Member` 엔티티와 다대일 관계를 갖습니다. `Member` 엔티티의 `id`를 가리키는`owner_id` 외래키를 갖습니다. 그 외에 `name`은 계좌명을, `balance`는 계좌의 잔고를 나타냅니다. `balance` 필드의 타입은 AccountBalance로,  다음과 같이 코틀린의 `value class`  문법과 `@JvmInline`  어노테이션을 사용하였습니다.
```kotlin
@JvmInline  
value class AccountBalance (val balance:Long):Serializable
```

value class를 사용했을 때의 장점은 타입 안정성을 보다 강화하는 것이라고 느꼈습니다. 실수로 다른 엔티티에서 사용하던 원시값을 혼동한다던가 하는 문제가 일어나지 않도록 보장할 수 있었습니다.

*Transaction* 엔티티는 계좌에서 금액을 송금하는 `fromAccount`와 금액을 송금받는 `toAccount` 두 개의 `Account`  엔티티 간의 다대다 관계를 표현합니다. 앞서 `Friendship`  엔티티와 달리, Transaction Entity는 방향성이 존재합니다.  따라서  금액을 송금하는  `Accout`  엔티티에 대해서만 Transaction을 추가하도록 구현하였습니다.

### API 명세

어플리케이션의 api 엔드포인트들에 대해 설명하기 전에, api 문서를 생성하기 위해 적용한 RestDocs를 사용하면서 느낀 점을 적어보려 합니다.

- Spring RestDocs를 사용해 각 엔드포인트에 대하여 RestDocs 테스트를 작성하고, asciidoctor 포맷으로 문서화하였습니다.
- 예외를 커스텀하고 `ControllerAdvice` 를 통해 처리하도록 구현하였습니다.
- 커스텀한 예외의 상태코드와 메세지는 `mockMvc` 를 사용한 테스트에서는 실제 어플리케이션 서블릿과 달리 모킹한 서블릿이 처리하지 않아 JSON 형태의 body에 포함되지 않는다는 점을 알게 되었습니다. 따라서 응답 본문만을 문서화하는 RestDocs 문서에는 포함시킬 수 없었던 것이 아쉬움이 남습니다.
- 응답 본문에 예외 메세지와 코드가 포함되는지를 테스트하기 위해서는 RestAssured나 TestRestTemplate 같이, 실제 서블릿을 사용하는 테스트 라이브러리를 사용해야 하나, 테스트에 의존성을 추가하는 것에 부담을 느껴서 RestDocs에는 정상 응답만을 문서화 하는 것에 만족하기로 했습니다.
- RestDocs를 사용하면서 느낀점은, 프로덕션 코드에 영향을 미치지 않는 점은 좋으나 별도의 테스트 설정/문법을 학습해야 하고, 설정이 생각보다 까다롭고 복잡하다는 점이 단점으로 다가왔습니다.
- 그러나 어느정도 러닝커브를 거치고 나니, asciidoc 문서나, 테스트 코드를 통해 문서 생성을 자동화할 수 있다는 점에 만족감을 느꼈습니다.



**로그인 [POST] /login**

- 로그인 서비스는 최소한의 Spring Security 설정을 통해 구현하고, 마지막으로 인증 필터에서 세션에 로그인한 유저의 아이디 정보를 전달하도록 하였습니다.
- 로그인과 회원가입 엔드포인트를 제외하고는 전부 인증이 필요하도록 처리하였고, 로그인 엔드포인트는 컨트롤러에는 따로 만들지 않고 spring security의 UsernamePasswordAuthenticationFilter가 사용하는 엔드포인트를 그대로 사용했습니다.
- 요청용 객체인 LoginRequest 클래스를 만들어 api request body 로 사용하였습니다.  이러한 요청용 값 객체는 코틀린의 data class를 사용하였고 직렬화 인터페이스를 구현했습니다.
- 값 객체/ DTO의 역할 분리에 대해 고민을 하게 되었습니다.  레이어간 값을 전달하는 객체는 DTO로 작성하면 되므로 단순했지만, 서비스에서 전달받은 DTO를 컨트롤러에서 최종적으로 반환할 때 응답 값 객체를 따로 반환해야하는지가 첫번째 고민거리였습니다.
- 제가 내린 결정은 요청용 객체는 값 객체로써 VO나 Request로 별도로 네이밍하고, DTO가 응답에 필요한 데이터를 적절하게 담고 있는 경우에는 별도의 응답용 VO를 만들지 않았습니다.
- 이렇게 결정하고 나니 실제로 응답 VO는 단 한개도 사용하지 않게 되었습니다.
- 그 이유를 살펴보면 우선 DTO 자체도 전부 코틀린의 데이터 클래스로 작성했기 때문에 불변 객체임이 보장되었으므로 Serializable을 구현하는 것에 문제가 없었고, 응답에 필요없는 데이터가 거의 없었기 때문입니다.
- 요청 객체의 네이밍 또한 Request와 VO 중에서 고민이 있었는데, 챗 GPT의 의견을 구하니 Request가 좀 더 목적을 잘 드러내는 네이밍 같다는 답을 주었고 저도 그에 공감이 되어 Request를 사용했습니다.


**회원가입 [POST] /signup**

- 마찬가지로 요청용 SignUpRequest 객체를 사용했습니다.
-  `Member` 엔티티의 `username` 필드를 `unique`  로 설정하여, 기존 테이블에 동일한 회원명이 존재할 시에 `UserAlreadyExistsException` 이라는 커스텀 예외를 발생시키고 응답 코드로는 409 리소스 충돌을 반환했습니다.


**친구목록 조회 [GET] /users/friends

- 별도의 요청 body 나 파라미터 없이 세션 id만으로 친구목록을 조회합니다.








